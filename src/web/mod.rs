use git_version::git_version;
use handlebars::{Context, Handlebars, Helper, HelperResult, Output, RenderContext, RenderError};
use image::open;
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};

use std::{
    fmt::{self, Display},
    fs,
    io::{BufRead, BufReader, Read, Write},
    net::{SocketAddr, TcpListener, TcpStream},
    path::PathBuf,
};

use crate::{
    algorithms::{bacteria_exclusion, determine_scale, graphene_angles, pre_processing},
    configuration::Configuration,
};

/// The HTML template used for the web interface
static INTERACTIVE_TEMPLATE: &str = include_str!("./template.html");

/// The handlebar instance used to generate the page
static HANDLEBARS: Lazy<Handlebars> = Lazy::new(create_handlebars);

// Paths to all static images generated by the program
static IMAGES: &[&str] = &[
    "/graphene.png",
    "/bacteria.png",
    "/angle-histogram.png",
    "/length-histogram.png",
    "/angles.png",
    "/artifacts.png",
    "/bacteria-exclusion.png",
];

// Starts listening for requests on the given socket address
pub fn start(address: SocketAddr) {
    println!("Starting webserver on http://{address}");
    let listener = TcpListener::bind(address).expect("Failed to bind to address");

    for stream in listener.incoming() {
        handle_connection(stream.unwrap());
    }
}

/// A HTTP status
enum HttpStatus {
    Ok,
    NotFound,
    InternalServerError,
}

impl Display for HttpStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HttpStatus::Ok => write!(f, "HTTP/1.1 200 OK"),
            HttpStatus::NotFound => write!(f, "HTTP/1.1 404 Not Found"),
            HttpStatus::InternalServerError => write!(f, "HTTP/1.1 500 Internal Server Error"),
        }
    }
}

/// Creates a complete HTTP request from status and content
fn body_byte(status: HttpStatus, content: &[u8]) -> Vec<u8> {
    let status_line = status.to_string();
    let length = content.len();

    // Create the response
    let mut bytes = format!("{status_line}\r\nContent-Length: {length}\r\n\r\n")
        .as_bytes()
        .to_vec();
    bytes.extend(content.iter());

    bytes
}

/// Creates a complete HTTP request from status and content
fn body(status: HttpStatus, content: &str) -> String {
    let status_line = status.to_string();
    let length = content.len();

    format!("{status_line}\r\nContent-Length: {length}\r\n\r\n{content}")
}

/// Handles incomming HTTP requests
fn handle_connection(mut stream: TcpStream) {
    // Extract http headers from request
    let buf_reader = BufReader::new(&mut stream);
    let http_header: Vec<_> = buf_reader
        .lines()
        .map(|result| result.unwrap())
        .take_while(|line| !line.is_empty())
        .collect();

    // Get the requested path
    let full_path = match http_header.first() {
        Some(status) if status.starts_with("GET") => {
            let full_path = status.split_whitespace().nth(1).unwrap();
            full_path
        }
        _ => {
            stream
                .write_all(body(HttpStatus::NotFound, "").as_bytes())
                .unwrap();
            return;
        }
    };

    // Extract path and query
    let (path, query) = if let Some((path, query)) = full_path.split_once("?") {
        (path, Some(query))
    } else {
        (full_path, None)
    };

    println!("Serving: \"{path}\"");

    // Serve the relevant content
    match path {
        // Serve interface
        "/" => serve_interface(query, &mut stream),

        // Serve the static images
        path if IMAGES.contains(&path) => {
            let prefix = match fs::read_to_string("./output/tmp") {
                Ok(prefix) => prefix,
                Err(_) => {
                    stream
                        .write_all(body(HttpStatus::NotFound, "").as_bytes())
                        .unwrap();
                    return;
                }
            };

            if let Ok(mut res) = fs::File::open(prefix + path.trim_start_matches('/')) {
                let mut data = Vec::new();
                res.read_to_end(&mut data).unwrap();

                stream.write_all(&body_byte(HttpStatus::Ok, &data)).unwrap();
            } else {
                stream
                    .write_all(body(HttpStatus::NotFound, "").as_bytes())
                    .unwrap();
            }
        }

        // Return the 404 Not Found for invalid routes
        _ => {
            stream
                .write_all(body(HttpStatus::NotFound, "").as_bytes())
                .unwrap();
        }
    };
}

/// Serves the default interface
fn serve_interface(query: Option<&str>, stream: &mut TcpStream) {
    // Derive the configuration from the query
    let mut settings = if let Some(query) = query {
        InteractiveConfiguration::from_query(&urlencoding::decode(query).unwrap())
            .expect("Failed to parse parameters")
    } else {
        InteractiveConfiguration::default()
    };

    // Save configuration if needed
    if settings.save_config {
        let config_string =
            toml::to_string_pretty(&settings.config).expect("Failed to serialize configuration");

        match fs::write(&settings.configuration_path, config_string) {
            Ok(_) => (),
            Err(e) => {
                settings.error = format!("Could not write to config file ({e})");
                stream
                    .write_all(
                        body(
                            HttpStatus::InternalServerError,
                            &HANDLEBARS.render("index", &settings).unwrap(),
                        )
                        .as_bytes(),
                    )
                    .unwrap();
                return;
            }
        }
    }

    // Load configuration if needed
    if settings.load_config {
        let config_string = match fs::read_to_string(&settings.configuration_path) {
            Ok(config) => config,
            Err(e) => {
                settings.error = format!("Failed to read the config file ({e})");
                stream
                    .write_all(
                        body(
                            HttpStatus::InternalServerError,
                            &HANDLEBARS.render("index", &settings).unwrap(),
                        )
                        .as_bytes(),
                    )
                    .unwrap();
                return;
            }
        };

        settings.config =
            toml::from_str(&config_string).expect("Couldn't parse the config file as TOML");

        // Warn about config using another version of the program
        if settings.config.program_version != git_version!() {
            eprintln!("Warning: the config you have provided was made by another version of the program. It might not reproduce the same results (config: {}, program: {})", settings.config.program_version, git_version!());
        }
    }

    // Load the given image
    let image = match open(&settings.path) {
        Ok(image) => image,
        Err(e) => {
            settings.error = format!("Could not load input image ({e})");
            stream
                .write_all(
                    body(
                        HttpStatus::InternalServerError,
                        &HANDLEBARS.render("index", &settings).unwrap(),
                    )
                    .as_bytes(),
                )
                .unwrap();
            return;
        }
    }
    .to_luma8();

    // Create an output prefix from the filename
    let output_prefix =
        "./output/".to_string() + settings.path.file_stem().unwrap().to_str().unwrap() + "_";

    // Determine the scale (um / px)
    let (scale, um, px, scale_bar_height, image) = match determine_scale(
        image,
        &settings.config.text_recognition,
        true,
        &output_prefix,
    ) {
        Ok(result) => result,
        Err(e) => {
            settings.error = format!("Failed to determine scale of image ({e})");
            stream
                .write_all(
                    body(
                        HttpStatus::InternalServerError,
                        &HANDLEBARS.render("index", &settings).unwrap(),
                    )
                    .as_bytes(),
                )
                .unwrap();
            return;
        }
    };

    settings.scale = format!(
        "Scale: {:.4} um/px (px: {}, um: {}, scale bar height: {})",
        scale, px, um, scale_bar_height
    );
    println!("{}", settings.scale);

    // Preprocessing
    let image = pre_processing(image, settings.config.pre_processing);

    // Find graphene and determine bacteria exclusion percentage
    if settings.config.bacteria_exclusion.enabled {
        let bacteria_exclusion = match bacteria_exclusion(
            &image,
            &settings.config.bacteria_exclusion,
            scale,
            true,
            &output_prefix,
        ) {
            Ok(bacteria_exclusion) => bacteria_exclusion,
            Err(e) => {
                settings.error = format!("Failed to calculate bacteria exclusion ({e})");
                stream
                    .write_all(
                        body(
                            HttpStatus::InternalServerError,
                            &HANDLEBARS.render("index", &settings).unwrap(),
                        )
                        .as_bytes(),
                    )
                    .unwrap();
                return;
            }
        };

        settings.bacteria_exclusion = format!(
            "Estimated bacteria exclusion: {:.3}%",
            bacteria_exclusion * 100.0
        );
        println!("{}", settings.bacteria_exclusion);
    }

    // Find angles of graphene in the image
    if settings.config.graphene_angles.enabled {
        graphene_angles(
            &image,
            &settings.config.graphene_angles,
            scale,
            true,
            &output_prefix,
        );
    }

    // Export the used configuration to the output directory
    fs::write(
        output_prefix.to_string() + "config.toml",
        toml::to_string_pretty(&settings.config).expect("Failed to serialize configuration"),
    )
    .expect("Failed to save output configuration file");

    // Export that prefix to a temporary file as a workaround to be able to know the file
    // prefix from the image serving below
    let mut tmp = fs::File::create("./output/tmp").expect("Failed to create temporary file");
    write!(tmp, "{output_prefix}").expect("Failed to write to temporary file");

    // Render the configuration using HANDLEBARS
    stream
        .write_all(
            body(
                HttpStatus::Ok,
                &HANDLEBARS.render("index", &settings).unwrap(),
            )
            .as_bytes(),
        )
        .unwrap();
    return;
}

fn create_handlebars() -> Handlebars<'static> {
    // register the template to a new handlebar instance (template engine)
    let mut handlebars = Handlebars::new();
    handlebars
        .register_template_string("index", INTERACTIVE_TEMPLATE)
        .expect("Failed to add template to HANDLEBARS");

    // Make HANDLEBARS strict, disallowing invalid fields
    handlebars.set_strict_mode(true);

    // Add helper to handle checkboxes in html
    handlebars.register_helper(
        "checkbox",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let param = h
                    .param(0)
                    .ok_or_else(|| RenderError::new("Checkbox takes exactly one argument"))?;

                out.write(
                    if param
                        .value()
                        .as_bool()
                        .ok_or_else(|| RenderError::new("The parameter isn't a boolean"))?
                    {
                        "checked=checked"
                    } else {
                        ""
                    },
                )?;

                Ok(())
            },
        ),
    );

    // Add helper to round floats in html to remove visable floating point errors
    handlebars.register_helper(
        "float",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let param = h
                    .param(0)
                    .ok_or_else(|| RenderError::new("Float parameter takes exactly argument"))?;

                // Round to 7 decimals and remove trailing zeros
                let mut formatted = format!(
                    "{:.7}",
                    param
                        .value()
                        .as_f64()
                        .ok_or_else(|| RenderError::new("The parameter is not a float"))?
                )
                .trim_end_matches('0')
                .to_string();

                if formatted.ends_with('.') {
                    formatted.push('0');
                }

                out.write(&formatted)?;

                Ok(())
            },
        ),
    );

    // Add helper to optionally create images
    handlebars.register_helper(
        "optional_image",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let flag = h
                    .param(0)
                    .ok_or_else(|| {
                        RenderError::new("The first parameter was not found, of at least 2")
                    })?
                    .value()
                    .as_bool()
                    .ok_or_else(|| RenderError::new("The flag is not a boolean"))?
                    && h.param(3).and_then(|v| v.value().as_bool()).unwrap_or(true);

                let image_source = h.param(1).ok_or_else(|| {
                    RenderError::new("The second parameter was not found, of at least 2")
                })?;

                // Only show the image if flag is on
                if flag {
                    if let Some(title) = h.param(2) {
                        out.write(&format!(
                            "<h3>{}</h3>",
                            title
                                .value()
                                .as_str()
                                .expect("The title has to be a string")
                        ))
                        .unwrap();
                    }

                    out.write(&format!(
                        "<img src=\"{}\">",
                        image_source
                            .value()
                            .as_str()
                            .ok_or_else(|| RenderError::new("The image source is not a string"))?,
                    ))
                    .unwrap();
                }

                Ok(())
            },
        ),
    );

    handlebars
}

#[derive(Debug)]
struct UnkownQueryParameter(String);

impl fmt::Display for UnkownQueryParameter {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Unknown query parameter {}", self.0)
    }
}

impl std::error::Error for UnkownQueryParameter {}

#[derive(Debug, Serialize, Deserialize)]
struct InteractiveConfiguration {
    config: Configuration,
    path: PathBuf,
    configuration_path: PathBuf,
    save_config: bool,
    load_config: bool,
    error: String,
    scale: String,
    artifacts: String,
    bacteria_exclusion: String,
    bacteria_coverage: String,
}

impl Default for InteractiveConfiguration {
    fn default() -> Self {
        InteractiveConfiguration {
            config: Configuration::default(),
            path: "example-sem-image-for-analysis.tif".into(),
            configuration_path: "./config.toml".into(),
            save_config: false,
            load_config: false,
            error: String::new(),
            scale: String::new(),
            artifacts: String::new(),
            bacteria_exclusion: String::new(),
            bacteria_coverage: String::new(),
        }
    }
}

impl InteractiveConfiguration {
    fn from_query(query: &str) -> Result<Self, Box<dyn std::error::Error>> {
        // Use the default configuration as a base
        let mut settings = Self::default();

        // Get all query parameters from query string
        for (name, value) in query.split('&').map(|pair| {
            let mut pair = pair.split('=');
            (pair.next().unwrap(), pair.next().unwrap())
        }) {
            match name {
                // General
                "path" => {
                    settings.path =
                        PathBuf::from(PathBuf::from(value).to_str().unwrap().replace('+', " "));
                }
                // Text recognition
                "text_bar_height" => {
                    settings.config.text_recognition.scale_bar_height = value.parse().unwrap();
                }
                "override_scale" => {
                    if value == "no" {
                        settings.config.text_recognition.override_scale = false;
                    } else if value == "on" {
                        settings.config.text_recognition.override_scale = true;
                    }
                }
                "override_scale_pixels" => {
                    settings.config.text_recognition.override_scale_pixels = value.parse().unwrap();
                }
                "override_scale_micrometers" => {
                    settings.config.text_recognition.override_scale_micrometers =
                        value.parse().unwrap();
                }
                // Bacteria exclusion
                "bacteria_exclusion" => {
                    if value == "no" {
                        settings.config.bacteria_exclusion.enabled = false;
                    } else if value == "on" {
                        settings.config.bacteria_exclusion.enabled = true;
                    }
                }
                "graphene_contrast_threshold" => {
                    settings.config.bacteria_exclusion.contrast_threshold = value.parse().unwrap();
                }
                "graphene_minimum_edge_area" => {
                    settings.config.bacteria_exclusion.minimum_edge_area = value.parse().unwrap();
                }
                "graphene_edge_bacteria_exclusion_radius" => {
                    settings.config.bacteria_exclusion.exclusion_radius = value.parse().unwrap();
                }
                // Graphene angles
                "graphene_angles" => {
                    if value == "no" {
                        settings.config.graphene_angles.enabled = false;
                    } else if value == "on" {
                        settings.config.graphene_angles.enabled = true;
                    }
                }
                "graphene_angle_contrast_threshold" => {
                    settings.config.graphene_angles.threshold = value.parse().unwrap();
                }
                "min_graphene_size" => {
                    settings.config.graphene_angles.min_graphene_size = value.parse().unwrap();
                }
                "min_graphene_ratio" => {
                    settings.config.graphene_angles.min_graphene_ratio = value.parse().unwrap();
                }
                // Export / import
                "configuration_path" => settings.configuration_path = value.into(),
                "save_config" => {
                    if value == "no" {
                        settings.save_config = false;
                    } else if value == "on" {
                        settings.save_config = true;
                    }
                }
                "load_config" => {
                    if value == "no" {
                        settings.load_config = false;
                    } else if value == "on" {
                        settings.load_config = true;
                    }
                }
                param => return Err(Box::new(UnkownQueryParameter(param.to_string()))),
            }
        }

        Ok(settings)
    }
}
